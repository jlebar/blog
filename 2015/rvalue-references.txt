title: A Gentle Introduction to Rvalue References
date: 2015-07-13 08:00
uuid: urn:uuid:ACF27684-B1CD-47A1-8C0D-C45653EBF905

One of the most complex and powerful features introduced in C++11 is the
concept of *rvalue references*.  We've been using C++11 for more than a year at
Google, and my experience is that rvalue references are by far the hardest new
C++11 feature for folks to pick up just by reading and writing code.

In this post I want to try to explain rvalue references from a user's
perspective.  Inasmuch as possible, I'm going to try not to get hung up in the
details of the spec; instead I'm going to focus on what you need in order to
understand the correctness and performance aspects of your C++11 code.

Let's get started.

## Motivation

It's important first to understand what the C++ standards committee was trying
to achieve by adding all this complexity to the language.

Rvalue references have three main uses:

 * Letting us avoid unnecessary copies,
 * Letting us "move" (i.e., transfer ownership of) objects which can't be
   copied (canonically, `std::unique_ptr`), and
 * Perfect forwarding.

We'll talk about just the first two in this post; perfect forwarding is mostly
useful to library writers.  For the moment, let's focus on the first one,
avoiding copies, and see how C++11 can help.

### Avoiding copies

Consider the following possible definition of std::vector<int>'s members:

  class vector<int> {
    int size;
    int capacity;
    int* elems;
  };

Now suppose we do:

  vector<int> GetVector() { ... }

  std::map<int, vector<int>> m;
  m[42] = GetVector();

Before C++11, here's what would happen:

 1. Return the vector from `GetVector`.  This may or may not require us to copy
    it, depending on whether we can perform [return value optimization (RVO)][RVO].
    In any case, let's call the returned object `x`.
 2. Because 42 is not in the map, we'll default-construct a second vector, `y`,
    in the map.
 3. m[42] returns a reference to `y`, so now we run `y = x`, which invokes
    `y`'s copy-constructor, `vector<int>::operator=(const vector<int>&)`.
    This malloc's new memory in `y` and copies `x`'s elements in there.
 4. Finally we destroy the temporary `x`, freeing its memory.

Now, the malloc + copy in step 3 is pretty silly.  We know that `x` is going
away, so it's wasteful to malloc `y.elems` and memcopy from `x.elems` into
`y.elems` when we could instead steal `x`'s pointer into `y` with something
like:

  y.elems = x.elems;
  x.elems = nullptr;

So long as `vector`'s destructor can handle a null `elems`, that's it, we're
done, constant time.

It's also pretty silly that we don't know in step 1 whether or not returning
the vector requires a copy.  Even if `GetVector` can't benefit from RVO, we
could apply the same pointer-stealing trick to avoid an expensive malloc + copy
+ free.

This is a general problem in C++ when dealing with objects which own
heap-allocated memory, and it has motivated plenty of unnatural idioms, such as
return-by-outparam.  C++11 largely fixes this for us: **In C++11, the above
code doesn't make any copies.**

This is an impressive achivement by the C++ standards committee: Without any
changes to your code, your program magically gets faster.  But the cost of this
magic is a fair bit of complexity, and that's what we're going to explore in
the rest of this post.  As we wade through the morass, keep this use-case in
mind.

RVO: http://en.cppreference.com/w/cpp/language/copy_elision

### Transfering ownership of uncopyable objects

TODO

## Mantras

Before we dig into the new semantics introduced in C++11, I want to offer two
non-obvious statements of fact about rvalue references.  I haven't defined or
even introduced most of these terms yet, but let them serve as questions: If
you believe these deep within your soul by the end of the post, you'll know
enough to start using rvalue references effectively.

### Mantra 1

*An rvalue reference is a reference \
to a temporary.*

The newline here is significant; you could end this mantra at the first line.
An rvalue reference is a reference, and for the most part it behaves just like
a regular, vanilla reference.  What's different about an rvalue reference is
that we know that the thing it's *pointing to* is a temporary.

Note that an rvalue reference is not itself a temporary; it's just a reference
to one.

### Mantra 2

*`std::move(x)` is a cast \
that lets us treat `x` as though it were a temporary.*

Again, you can stop at the first line; `std::move` is just a cast, like
`static_cast` or `const_cast`.  Just as `const_cast<Foo>(x)` has no effect
beyond allowing us to treat `x` as a non-const `Foo`, so too does `std::move`
have no effect beyond allowing us to treat `x` as though it were a temporary.

(In this sense `std::move` is confusingly named; it sounds like it *does*
something, even though it doesn't.  Maybe `rvalue_cast` -- read
`temporary_cast` -- would have been a better name.  But you'll see that
`std::move` scans well in practice, even if it's misleading.)

## Temporaries, references, and rvalue references

Before we can talk about rvalue references, we need to investigate a corner of
the C++ type system that existed before C++11.

Consider the following code.  Which of the lines do and don't compile?

    string GetString();

    void run() {
      string x = "abc";

      string& a = x;                  // 1
      string& b = GetString();        // 2
      const string& c = x;            // 3
      const string& d = GetString();  // 4
    }

If you try it out, you'll see that line (2) is a compile error (both in C++03
and C++11); the rest are OK.  What's special about (2)?

The reason (2) is an error is that temporaries cannot bind to non-const
references.  For our purposes, a **temporary** is just something that you can
only use once.  Here `GetString()` is a temporary: You can call `.length()` or
`.c_str()` or whatever you like on `GetString()`, but once you do, the original
string is no longer accessible; you can't call something else on it.

(I think the motivation for this rule is, if you're binding a non-const
reference to a temporary, it's presumably because you want to modify that
thing.  But it's a temporary variable, so any modifications you're going to
make are going to disappear when the variable goes away.  I might argue, well,
*all* variables in your program are temporary, in the sense that they go away
when the program exits, so this is perhaps a vapid distinction, but hey, I
don't make the rules.)

The above is a contrived example, but this rule is particularly important when
it comes to function overloading.  Consider the following code.  What does
run() print?

    string GetString();
    void Fn(string& s) { printf("A"); }        // Overload A
    void Fn(const string& s) { printf("B"); }  // Overload B

    void run() {
      string x = "abc";
      Fn(x);             // 1
      Fn(GetString());   // 2
    }

The call to `Fn` in line (1) passes a non-temporary string, so it can bind to
overload A or B.  C++'s function overloading rules bind us to the "most
specific" function call, which is the non-const ref, in A.  The call in (2)
passes a temporary string, so can only bind to overload B.  So run() calls A
and then B.

Let's represent this rule with a table:

             const T&  T&
    temp           ok   -
    non-temp       ok  ok

When I see a table like this, I think the natural question is, does there exist
something which is the reverse of `T&` -- that is, which will bind to a
temporary but not a non-temporary?

There is such a thing, in C++11: the **rvalue reference**, spelled `T&&`.

             const T&  T&  T&&
    temp           ok   -   ok
    non-temp       ok  ok    -

(Don't try to parse the `&&` as "reference-to-a-reference"; it's a single
unit.)

Again the main impact of this new reference type can be seen when we consider
function overloading.  Consider the following slightly-modified version of the
last example.

    string GetString();
    void Fn(string& s) { printf("A"); }        // Overload A
    void Fn(const string& s) { printf("B"); }  // Overload B
    void Fn(string&& s) { printf("C"); }       // Overload C

    void run() {
      string x = "abc";
      Fn(x);             // 1
      Fn(GetString());   // 2
      Fn(std::move(x));  // 3
    }

Here (1) still binds to A as before. But now (2) could bind to B or C.  The
rules say we choose C, the more-specific one.

As for (3), we now have a use for mantra 2: `std::move` just imbues `x` with
temporaryness; thus, we call overload C, just like in line (2).

It's important to note that call (3) *does not* modify x!  All we did was
pretend that x was a temporary and then take a reference to it.  Nowhere here
do we modify x.

One last thing -- and this is probably the most surprising piece of code I can
show about rvalue references.  Suppose we modify the code above so that
Fn(string&&) is recursive:

    void Fn(string& s) { printf("A"); }         // Overload A
    void Fn(const string& s) { printf("B"); }   // Overload B
    void Fn(string&& s) { Fn(s); }              // Overload C (modified)

Overload C [is *not* infinitely recursive][https://goo.gl/i3WAEI].  In fact it
just calls overload A.  Why?  Well, within overload (C), `s` is not itself a
temporary, because you can use `s` more than once.  `s` is merely a *reference*
to a temporary that lives in some other scope (mantra 1).  Therefore `Fn(s)`
can't bind to overload (C), which expects a bona-fide temporary; it has to bind
to (A) or (B).  (A) is more restrictive, so we choose that one.

`Fn(std::move(s))` would be infinite recursion.

What we've seen in this section is that C++11 expands upon C++03's notion of
temporary expressions by introducing a new reference type which can only point
to temporaries.  Now I need to show why this is useful.
